# Pastelería Bella - Backend API - Reglas del Proyecto

## Stack Tecnológico (NO CAMBIAR)

- **NestJS 10+** - Framework backend
- **PostgreSQL** + **Prisma** - Base de datos y ORM
- **TypeScript** estricto
- **class-validator** y **class-transformer** para validación de DTOs (OBLIGATORIO)
- **@nestjs/swagger** para documentación de API (OBLIGATORIO)
- **bcryptjs** para passwords

## Restricciones Arquitectónicas

1. **Arquitectura modular** - Usar módulos NestJS (ProductsModule, OrdersModule, etc.)
2. **NO acceso directo a DB** - Todo vía Prisma Service
3. **NO Supabase Auth** - Autenticación propia con bcrypt + JWT/cookies
4. **Separación de responsabilidades** - Controller → Service → Prisma
5. **Implementar por incrementos pequeños** - Cero refactors grandes

## Estructura de Carpetas

```
pasteleria-api/
├── src/
│   ├── products/          # Módulo de productos
│   │   ├── products.controller.ts
│   │   ├── products.service.ts
│   │   └── products.module.ts
│   ├── orders/            # Módulo de pedidos
│   ├── auth/              # Módulo de autenticación
│   ├── prisma/            # Servicio Prisma (global)
│   │   ├── prisma.service.ts
│   │   └── prisma.module.ts
│   ├── app.module.ts      # Módulo principal
│   └── main.ts            # Bootstrap de la aplicación
├── prisma/
│   ├── schema.prisma      # Esquema de base de datos
│   ├── migrations/        # Migraciones
│   └── seed.ts            # Seed de datos iniciales
└── [config files]
```

## Reglas de Negocio (Chile V1)

### Precios
- **IVA incluido** - Todos los precios son finales (priceCLP ya incluye IVA)
- **CLP como INT** - Todos los precios en pesos chilenos son enteros (sin decimales)
  - `priceCLP Int` (NO Decimal)
  - `totalCLP Int`
  - `unitPriceCLP Int`
  - `lineTotalCLP Int`
  - `amountCLP Int`
- Formato CLP: usar separadores de miles (ej: $15.990)
- **Razón**: Evita problemas de formateo, sumas y UI con decimales innecesarios

### Horario de Atención
- **09:00 a 17:00** - Validar checkout dentro de este horario (server-side)
- Validación en service con función `isValidBusinessHours()`

### Delivery y Retiro
- **Delivery propio** y **Retiro en tienda** (fulfillmentType: DELIVERY | PICKUP)
- **Zona delivery inicial**: Solo "Santiago Centro"
- Validar zona en service si fulfillmentType = DELIVERY
- **Sin cupos por ventana horaria** (V1)

### Roles V1 (Obligatorios)
- `SUPER_ADMIN` - Acceso total
- `JEFE_VENTAS` - Reportes
- `PRODUCCION` - Inventario/stock, CRUD productos
- `RECEPCION` - Gestiona pedidos y prepara despacho
- `DELIVERY` - Marca estados de entrega

### Estados de Pedido V1
- `CREADO` - Pedido creado, pendiente de pago
- `PAGADO` - Pago confirmado
- `EN_PREPARACION` - En preparación
- `LISTO` - Listo para entrega/retiro
- `EN_RUTA` - Solo para delivery, en camino
- `ENTREGADO` - Delivery completado
- `RETIRADO` - Retiro en tienda completado
- `CANCELADO` - Pedido cancelado

### Transiciones de Estado (Validar en service)
- `PAGADO` → `EN_PREPARACION` (solo RECEPCION)
- `EN_PREPARACION` → `LISTO` (solo RECEPCION)
- `LISTO` → `EN_RUTA` (solo si fulfillmentType = DELIVERY, solo RECEPCION)
- `LISTO` → `RETIRADO` (solo si fulfillmentType = PICKUP, solo RECEPCION)
- `EN_RUTA` → `ENTREGADO` (solo RECEPCION o DELIVERY)
- Cualquier estado → `CANCELADO` (solo SUPER_ADMIN)

## Seguridad (Obligatorio)

1. **Validación con class-validator** en TODOS los DTOs (Data Transfer Objects)
2. **Guards NestJS** para RBAC (Roles Based Access Control)
3. **Variables de entorno** para secretos (DATABASE_URL, JWT_SECRET, SESSION_SECRET)
4. **Passwords hasheados** con bcrypt (10 rounds mínimo)
5. **Cookies httpOnly** para sesiones (si se usa)
6. **Transacciones Prisma** para operaciones críticas (pago + inventario)
7. **Validación automática** habilitada con `ValidationPipe` en `main.ts`

## Arquitectura NestJS

### Estructura de Módulos

**Patrón estándar por módulo:**
```
module-name/
├── module-name.controller.ts  # Endpoints HTTP
├── module-name.service.ts     # Lógica de negocio
├── module-name.module.ts       # Configuración del módulo
├── dto/                        # Data Transfer Objects (OBLIGATORIO)
│   ├── create-module-name.dto.ts
│   ├── update-module-name.dto.ts
│   └── module-name-response.dto.ts
└── facade/                     # Facade Pattern (cuando sea necesario)
    └── module-name.facade.ts
```

## Patrones de Diseño

### DTOs (Data Transfer Objects) - OBLIGATORIO

**Propósito:**
- Validar y tipar datos de entrada/salida
- Separar la estructura de datos de los modelos de Prisma
- Documentar la API con Swagger
- Prevenir inyección de datos inválidos

**Reglas de Implementación:**

1. **Crear DTOs para TODOS los endpoints que reciben datos:**
   - `POST` → `CreateXxxDto`
   - `PATCH/PUT` → `UpdateXxxDto`
   - `GET` con query params → `QueryXxxDto`
   - Respuestas complejas → `XxxResponseDto`

2. **Ubicación:**
   - Carpeta `dto/` dentro de cada módulo
   - Nombre: `{action}-{module-name}.dto.ts`
   - Ejemplo: `create-product.dto.ts`, `update-product.dto.ts`, `product-response.dto.ts`

3. **Validación con class-validator:**
   ```typescript
   import { IsString, IsInt, IsOptional, Min, Max, IsEmail } from 'class-validator'
   import { ApiProperty } from '@nestjs/swagger'
   
   export class CreateProductDto {
     @ApiProperty({ description: 'Nombre del producto', example: 'Torta de Chocolate' })
     @IsString()
     @IsNotEmpty()
     name: string
   
     @ApiProperty({ description: 'Descripción del producto', required: false })
     @IsString()
     @IsOptional()
     description?: string
   
     @ApiProperty({ description: 'Precio en CLP (IVA incluido)', example: 15990 })
     @IsInt()
     @Min(0)
     priceCLP: number
   }
   ```

4. **Decoradores obligatorios:**
   - `@ApiProperty()` de `@nestjs/swagger` para documentación
   - Validadores de `class-validator`: `@IsString()`, `@IsInt()`, `@IsEmail()`, etc.
   - `@IsOptional()` para campos opcionales
   - `@Min()`, `@Max()`, `@Length()` para validaciones numéricas/de longitud

5. **Uso en Controllers:**
   ```typescript
   @Post()
   @ApiOperation({ summary: 'Crear un nuevo producto' })
   @ApiResponse({ status: 201, description: 'Producto creado exitosamente' })
   async create(@Body() createProductDto: CreateProductDto) {
     return this.productsService.create(createProductDto)
   }
   ```

6. **Response DTOs:**
   - Crear DTOs de respuesta para estructurar datos de salida
   - Excluir campos sensibles (passwordHash, tokens internos)
   - Transformar datos de Prisma a formato de respuesta

**Ejemplo completo:**
```typescript
// dto/create-product.dto.ts
import { IsString, IsInt, IsOptional, Min, IsUrl } from 'class-validator'
import { ApiProperty } from '@nestjs/swagger'

export class CreateProductDto {
  @ApiProperty({ example: 'Torta de Chocolate' })
  @IsString()
  name: string

  @ApiProperty({ required: false })
  @IsString()
  @IsOptional()
  description?: string

  @ApiProperty({ example: 15990 })
  @IsInt()
  @Min(0)
  priceCLP: number

  @ApiProperty({ required: false })
  @IsUrl()
  @IsOptional()
  imageUrl?: string
}
```

### Facade Pattern

**Propósito:**
- Simplificar interfaces complejas
- Agrupar múltiples operaciones relacionadas
- Ocultar complejidad de múltiples services
- Proporcionar una API unificada y simple

**Cuándo usar Facade:**
- Cuando un endpoint requiere múltiples operaciones de diferentes services
- Para operaciones de negocio complejas que involucran varios módulos
- Para simplificar la interacción entre frontend y backend
- Cuando hay lógica de orquestación entre múltiples services

**Estructura:**
```
module-name/
└── facade/
    └── module-name.facade.ts
```

**Reglas de Implementación:**

1. **El Facade coordina múltiples services:**
   ```typescript
   @Injectable()
   export class OrdersFacade {
     constructor(
       private ordersService: OrdersService,
       private paymentsService: PaymentsService,
       private inventoryService: InventoryService,
     ) {}
   
     async createOrderWithPayment(createOrderDto: CreateOrderDto) {
       // 1. Crear pedido
       const order = await this.ordersService.create(createOrderDto)
       
       // 2. Procesar pago
       const payment = await this.paymentsService.process(order.id, createOrderDto.payment)
       
       // 3. Descontar inventario
       await this.inventoryService.decreaseStock(order.items)
       
       return { order, payment }
     }
   }
   ```

2. **El Facade NO contiene lógica de negocio:**
   - La lógica de negocio va en los services individuales
   - El Facade solo orquesta y coordina

3. **Uso en Controllers:**
   ```typescript
   @Controller('orders')
   export class OrdersController {
     constructor(private ordersFacade: OrdersFacade) {}
   
     @Post()
     async create(@Body() createOrderDto: CreateOrderDto) {
       return this.ordersFacade.createOrderWithPayment(createOrderDto)
     }
   }
   ```

4. **Casos de uso comunes:**
   - Crear pedido + procesar pago + descontar inventario
   - Cancelar pedido + reembolsar + restaurar inventario
   - Actualizar estado de pedido + notificar + actualizar inventario

**Ejemplo completo:**
```typescript
// facade/orders.facade.ts
import { Injectable } from '@nestjs/common'
import { OrdersService } from '../orders.service'
import { PaymentsService } from '../../payments/payments.service'
import { InventoryService } from '../../inventory/inventory.service'
import { CreateOrderDto } from '../dto/create-order.dto'

@Injectable()
export class OrdersFacade {
  constructor(
    private ordersService: OrdersService,
    private paymentsService: PaymentsService,
    private inventoryService: InventoryService,
  ) {}

  async createOrderWithPayment(dto: CreateOrderDto) {
    // Orquestar múltiples operaciones
    const order = await this.ordersService.create(dto)
    const payment = await this.paymentsService.process(order.id, dto.payment)
    
    if (payment.status === 'PAID') {
      await this.inventoryService.decreaseStock(order.items)
    }
    
    return { order, payment }
  }
}
```

### Swagger (Documentación de API)

**Propósito:**
- Documentación automática e interactiva de la API
- Testing de endpoints desde el navegador
- Validación de contratos API
- Facilita integración frontend/backend

**Configuración:**

1. **Instalar dependencias:**
   ```bash
   npm install @nestjs/swagger swagger-ui-express
   ```

2. **Configurar en `main.ts`:**
   ```typescript
   import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'
   
   const config = new DocumentBuilder()
     .setTitle('Pastelería Bella API')
     .setDescription('API REST para Pastelería Bella')
     .setVersion('1.0')
     .addTag('products', 'Endpoints de productos')
     .addTag('orders', 'Endpoints de pedidos')
     .build()
   
   const document = SwaggerModule.createDocument(app, config)
   SwaggerModule.setup('api/docs', app, document)
   ```

3. **Decoradores en Controllers:**
   ```typescript
   @Controller('products')
   @ApiTags('products')
   export class ProductsController {
     @Get()
     @ApiOperation({ summary: 'Obtener todos los productos activos' })
     @ApiResponse({ 
       status: 200, 
       description: 'Lista de productos',
       type: [ProductResponseDto]
     })
     async findAll() {
       return this.productsService.findAll()
     }
   }
   ```

4. **Decoradores en DTOs:**
   - `@ApiProperty()` en cada propiedad del DTO
   - `@ApiPropertyOptional()` para campos opcionales
   - Ejemplos y descripciones claras

**Reglas de Documentación:**

- **TODOS los endpoints deben estar documentados**
- **TODOS los DTOs deben tener `@ApiProperty()` en cada campo**
- Usar `@ApiTags()` para agrupar endpoints relacionados
- Usar `@ApiOperation()` para describir cada endpoint
- Usar `@ApiResponse()` para documentar respuestas posibles
- Incluir ejemplos en `@ApiProperty()` para claridad

**Acceso a Swagger:**
- URL: `http://localhost:3001/api/docs`
- Interfaz interactiva para probar endpoints
- Documentación automática basada en decoradores

**Ejemplo completo:**
```typescript
@Controller('products')
@ApiTags('products')
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Get()
  @ApiOperation({ summary: 'Obtener todos los productos activos' })
  @ApiResponse({ 
    status: 200, 
    description: 'Lista de productos activos',
    type: [ProductResponseDto]
  })
  async findAll() {
    return this.productsService.findAll()
  }

  @Post()
  @ApiOperation({ summary: 'Crear un nuevo producto' })
  @ApiResponse({ 
    status: 201, 
    description: 'Producto creado exitosamente',
    type: ProductResponseDto
  })
  @ApiResponse({ 
    status: 400, 
    description: 'Datos inválidos'
  })
  async create(@Body() createProductDto: CreateProductDto) {
    return this.productsService.create(createProductDto)
  }
}
```

### Prisma Service (Global)

- **Ubicación**: `src/prisma/prisma.service.ts`
- **Módulo**: `PrismaModule` marcado como `@Global()`
- **Uso**: Inyectar `PrismaService` en cualquier service
- **Conexión**: Se conecta automáticamente en `onModuleInit()`

**Ejemplo de uso:**
```typescript
@Injectable()
export class ProductsService {
  constructor(private prisma: PrismaService) {}
  
  async findAll() {
    return this.prisma.product.findMany()
  }
}
```

### Controllers

- **Decoradores**: `@Controller('ruta')` para definir ruta base
- **Métodos HTTP**: `@Get()`, `@Post()`, `@Patch()`, `@Delete()`
- **Validación**: Usar `@Body()` con DTOs tipados y validación automática
- **Respuestas**: Retornar objetos directamente (NestJS serializa a JSON)
- **Swagger**: Usar `@ApiTags()`, `@ApiOperation()`, `@ApiResponse()` para documentación

**Ejemplo:**
```typescript
@Controller('products')
@ApiTags('products')
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Get()
  @ApiOperation({ summary: 'Obtener todos los productos activos' })
  @ApiResponse({ status: 200, type: [ProductResponseDto] })
  async findAll() {
    return this.productsService.findAll()
  }

  @Post()
  @ApiOperation({ summary: 'Crear un nuevo producto' })
  @ApiResponse({ status: 201, type: ProductResponseDto })
  async create(@Body() createProductDto: CreateProductDto) {
    return this.productsService.create(createProductDto)
  }
}
```

### Services

- **Lógica de negocio**: Toda la lógica va en services, NO en controllers
- **Inyección de dependencias**: Usar constructor injection
- **Transacciones**: Usar `prisma.$transaction()` para operaciones atómicas

### CORS

- **Configurado en**: `src/main.ts`
- **Origen permitido**: `FRONTEND_URL` desde variables de entorno (default: http://localhost:3000)
- **Credenciales**: Habilitadas para cookies/sesiones

### Prefijo Global

- **Prefijo**: `/api` configurado en `main.ts`
- **Rutas finales**: `/api/products`, `/api/orders`, etc.

## Base de Datos (Prisma)

### Modelos Obligatorios
- `User` - email, passwordHash, role
- `Product` - name, description, priceCLP (Int), imageUrl, active, stock
- `Order` - customerName, customerEmail, customerPhone, fulfillmentType, deliveryAddress, zone, totalCLP (Int), status, publicToken (String @unique)
- `OrderItem` - orderId, productId, quantity, unitPriceCLP (Int), lineTotalCLP (Int)
- `Payment` - orderId, provider (MOCK), status (PAID|FAILED), amountCLP (Int)
- `InventoryMovement` - productId, type (IN|OUT|ADJUST), quantity, reason, userId
- `DeliveryAssignment` - orderId, deliveryUserId, status

### Tracking Público de Pedidos
- `Order.publicToken` - Token único generado al crear pedido (String @unique)
- Endpoint público: `GET /api/orders/:id?token=:publicToken`
- Validar que el token coincida con el pedido antes de mostrar información
- Usar para tracking sin autenticación (cliente ve su pedido con id + token)

### Reglas Prisma
- **Service singleton** - Usar `PrismaService` inyectado
- **Solo acceso desde server** - NUNCA exponer Prisma directamente
- **Transacciones** para operaciones críticas (pago + inventario)

## Inventario

### Descuento Automático
- Al pasar Order a `PAGADO`, descontar stock automáticamente
- Crear `InventoryMovement` (type: OUT, reason: "Venta pedido #X")
- Validar stock suficiente antes de descontar (rollback si falla)
- Usar transacción Prisma

### Ajuste Manual
- Solo rol `PRODUCCION` puede ajustar stock
- Crear `InventoryMovement` (type: ADJUST) con razón
- Validar permisos con Guards

## Endpoints API

### Estructura
- Todas las rutas tienen prefijo `/api`
- Usar decoradores NestJS (`@Get()`, `@Post()`, etc.)
- **Validación OBLIGATORIA** con DTOs y `class-validator`
- **Documentación OBLIGATORIA** con Swagger (`@ApiTags()`, `@ApiOperation()`, `@ApiResponse()`)
- Guards para autenticación/autorización
- Usar Facade pattern cuando un endpoint requiera múltiples operaciones

### Endpoints Principales
- `POST /api/auth/login` - Login
- `POST /api/auth/logout` - Logout
- `GET /api/products` - Listar productos activos
- `GET /api/products/:id` - Producto por ID
- `POST /api/orders` - Crear pedido (genera publicToken)
- `GET /api/orders` - Listar pedidos (admin, requiere auth)
- `GET /api/orders/:id?token=:publicToken` - Pedido por ID (público, requiere token)
- `PATCH /api/orders/:id` - Actualizar estado (admin, requiere auth)
- `POST /api/payments` - Procesar pago mock
- `POST /api/inventory/adjust` - Ajustar stock
- `GET /api/inventory/movements` - Historial movimientos
- `GET /api/reports/sales` - Reporte ventas

## Testing y Validación

### Por Commit
- Cada commit debe dejar el sistema **runnable**
- Probar endpoints después de cada commit
- Verificar que no hay errores de TypeScript
- Verificar que Prisma Client se genera correctamente

### Validaciones Comunes
- TypeScript compila sin errores
- `npm run dev` inicia correctamente
- Prisma migrations ejecutadas
- Seed ejecutado (datos iniciales)
- Endpoints responden correctamente

## Buenas Prácticas

### Código
- **TypeScript estricto** - Habilitar strict mode
- **Nombres descriptivos** - Variables y funciones claras
- **Comentarios** - Solo cuando sea necesario explicar lógica compleja
- **DRY** - No repetir código, usar servicios reutilizables
- **Single Responsibility** - Cada service/controller tiene una responsabilidad

### Performance
- **Prisma Service singleton** - Un solo cliente por instancia
- **Paginación** en listados grandes (opcional V1)
- **Índices DB** en campos frecuentes (Order.status, Product.active)
- **Queries optimizadas** - Usar `select` para campos específicos cuando sea necesario

### Seguridad
- **Validación de inputs** - Siempre validar datos de entrada
- **Sanitización** - Limpiar datos antes de guardar
- **Error handling** - Manejar errores apropiadamente sin exponer información sensible

## Variables de Entorno

### Requeridas
- `DATABASE_URL` - URL de conexión PostgreSQL
- `PORT` - Puerto del servidor (default: 3001)
- `FRONTEND_URL` - URL del frontend para CORS (default: http://localhost:3000)

### Opcionales
- `JWT_SECRET` - Secreto para JWT (si se usa)
- `SESSION_SECRET` - Secreto para cookies de sesión (si se usa)
- `NODE_ENV` - development | production

## Notas Importantes

- **Chile V1** - Reglas específicas para mercado chileno (IVA incluido, horario, zona)
- **Vertical slice primero** - Flujo completo funcional antes de features adicionales
- **Sin refactors grandes** - Implementar por incrementos pequeños
- **Separación frontend/backend** - El frontend consume APIs, NO accede directamente a Prisma
- **CORS configurado** - Permite requests desde el frontend Next.js
